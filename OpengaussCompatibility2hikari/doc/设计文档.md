# 设计文档

## 项目背景

本项目需要基于 hikari 框架，分别使用 MySQL 驱动和 openGauss (PG) 驱动连接 openGauss ，对 hikari 的全量 API 接口进行测试。

**技术要求：**

1. 了解 JDBC 的使用方式
2. 连接 openGauss 的基础功能
3. 熟悉 Java 编程开发

**项目产出：**

1. 基于 hikari 框架，编写应用代码。分别使用 MySQL 驱动和 PG 驱动连接 openGauss ，获取 hikari 框架的全量 API 接口，利用 openGauss 常用的 DDL、DML、DCL、存储过程等语法测试相关 API 接口，输出测试结果
2. 输出测试设计文档，测试设计文档需合入 openGauss 社区
3. 输出测试报告，测试报告需合入 openGauss 社区



## 用于兼容性测试的检查项设计

### 兼容性测试

**数据库功能兼容**

+ 验证 HikariCP 是否支持 OpenGauss 数据库特有的功能和数据类型，如dolphin插件语法
+ 验证 HikariCP 对 OpenGauss 的 SQL 语法和存储过程的支持

**JDBC 驱动兼容**

+ 测试 HikariCP 与 PG JDBC\MySQL JDBC 驱动的兼容性
+ 测试驱动功能在 HikariCP 中兼容性



### 基本操作测试

**SQL 执行**

+ 执行基本的 SQL 语句（如 'SELECT', 'INSERT', 'UPDATE', 'DELETE'）是否能够正常执行
+ 测试复杂的 SQL 语句和事务（如'JOIN', 'GROUP BY', 'ORDER BY', 事务的提交和回滚）

**事务处理**

+ 测试事务的提交和回滚在 HikariCP 和 openGauss 数据库之间能否正确同步
+ 测试事务的隔离级别，数据一致性



### 异常处理测试

**连接失效处理**

+ 测试 HikariCP 在连接失效或数据库重启时处理能力
+ 验证 HikariCP 能够正确处理连接池中坏连接，并自动恢复

**超时处理**

+ 测试连接超时、查询超时等各种超时配置是否生效
+ 验证超时错误能否被正确捕获和处理



### 配置验证

**配置参数测试**

+ 验证 HikariCP 的各种配置（如连接池大小、超时设置等）是否对 openGauss 数据库有效，并验证配置变更能否被正确应用且对性能产生预期影响
+ 更换各种配置组合，对 HikariCP 的全量 API 接口进行测试

**日志记录**

+ 确保 HikariCP 的日志记录功能正常，能够记录连接池的状态、性能指标和错误信息
+ 验证日志信息对应于 openGauss 数据库的完整性和准确性



### 资源管理

**资源泄露检查**

+ 验证 HikariCP 是否能正确管理数据库连接，避免资源泄露
+ 验证所有连接在使用后是否能够被正确关闭，且连接池中不会出现泄露的连接

**内存使用**

+ 监控 HikariCP 在长时间运行中的内存使用情况，确保没有内存泄露
+ 监控 HikariCP 内存使用情况，观察连接池操作期间有没有异常增长



## 设计细节

### 环境配置

+ 虚拟机：Centos7.6 + openGauss Server 5.0.1
+ 物理机：win11 + java 11.0.21 + mysql-connector 8.0.11 / PG-connectors 5.0.1 + HikariCP 5.0.1



### 测试数据

 TPC-DS/TPC-H 表和数据，生成 1G 数据。使用原 TPC-DS 查询作为慢 SQL 进行测试，并在此基础上新增多条事务 SQL 。测试数据用于模拟负载生成器生成数据库负载。

**示例**

~~~sql
-- DDL
-- 创建用户 jim，设置密码
CREATE USER jim PASSWORD 'jim@1234';
-- SELECT * FROM pg_roles;
-- 创建数据库 music2，所有者为 jim
CREATE DATABASE music2 OWNER jim;
-- SELECT datname, pg_catalog.pg_get_userbyid(datdba) AS owner FROM pg_database;
-- 修改数据库 music2 的所有者为 omm
ALTER DATABASE music2 OWNER TO omm;
-- SELECT datname, pg_catalog.pg_get_userbyid(datdba) AS owner FROM pg_database;
-- 删除数据库 music2
DROP DATABASE music2;
-- SELECT datname, pg_catalog.pg_get_userbyid(datdba) AS owner FROM pg_database;
-- 修改用户 jim 的密码为 'Abcd@123'，并替换旧密码
ALTER USER jim IDENTIFIED BY 'Abcd@123' REPLACE 'jim@1234';
-- 创建角色 manager，并设置密码
CREATE ROLE manager IDENTIFIED BY 'manager@1234';
-- SELECT * FROM pg_roles;
-- 为角色 manager 添加 SYSADMIN 权限
ALTER ROLE manager SYSADMIN;
-- SELECT * FROM pg_roles;
-- 删除角色 manager
DROP ROLE manager;
-- SELECT * FROM pg_roles;
-- 创建表 jim.warehouse_t1，包含仓库信息
CREATE TABLE IF NOT EXISTS jim.warehouse_t1 (
    W_WAREHOUSE_SK            INTEGER               NOT NULL,  -- 仓库唯一标识符
    W_WAREHOUSE_ID            CHAR(16)              NOT NULL,  -- 仓库 ID
    W_WAREHOUSE_NAME          VARCHAR(20),                   -- 仓库名称
    W_WAREHOUSE_SQ_FT         INTEGER,                       -- 仓库面积（平方英尺）
    W_STREET_NUMBER           CHAR(10),                      -- 街道号码
    W_STREET_NAME             VARCHAR(60),                   -- 街道名称
    W_STREET_TYPE             CHAR(15),                      -- 街道类型
    W_SUITE_NUMBER            CHAR(10),                      -- 套房号码
    W_CITY                    VARCHAR(60),                   -- 城市
    W_COUNTY                  VARCHAR(30),                   -- 县
    W_STATE                   CHAR(2),                       -- 州
    W_ZIP                     CHAR(10),                      -- 邮政编码
    W_COUNTRY                 VARCHAR(20),                   -- 国家
    W_GMT_OFFSET              DECIMAL(5,2)                  -- GMT 偏移量
);
-- 创建表 jim.warehouse_t17，设置列存储和高压缩
CREATE TABLE IF NOT EXISTS jim.warehouse_t17 (
    W_WAREHOUSE_SK            INTEGER               NOT NULL,
    W_WAREHOUSE_ID            CHAR(16)              NOT NULL,
    W_WAREHOUSE_NAME          VARCHAR(20),
    W_WAREHOUSE_SQ_FT         INTEGER,
    W_STREET_NUMBER           CHAR(10),
    W_STREET_NAME             VARCHAR(60),
    W_STREET_TYPE             CHAR(15),
    W_SUITE_NUMBER            CHAR(10),
    W_CITY                    VARCHAR(60),
    W_COUNTY                  VARCHAR(30),
    W_STATE                   CHAR(2),
    W_ZIP                     CHAR(10),
    W_COUNTRY                 VARCHAR(20),
    W_GMT_OFFSET              DECIMAL(5,2)
) WITH (ORIENTATION = COLUMN, COMPRESSION = HIGH);
-- SELECT table_schema,table_name FROM information_schema.tables WHERE table_schema = 'jim';
-- 将 W_WAREHOUSE_SQ_FT 列设置为 NOT NULL
ALTER TABLE jim.warehouse_t1 ALTER COLUMN W_WAREHOUSE_SQ_FT SET NOT NULL;
-- SELECT column_name, data_type, is_nullable, column_default FROM information_schema.columns WHERE table_schema = 'jim' AND table_name = 'warehouse_t1';
-- 创建新的用户架构 joe
CREATE SCHEMA joe;
-- SELECT nspname AS schema_name,pg_catalog.pg_get_userbyid(nspowner) AS owner FROM pg_catalog.pg_namespace WHERE nspname NOT LIKE 'pg_%' AND nspname != 'information_schema';
-- 将 jim.warehouse_t1 移动到 joe 架构
ALTER TABLE jim.warehouse_t1 SET SCHEMA joe;
-- SELECT table_schema,table_name FROM information_schema.tables WHERE table_schema = 'jim';
-- SELECT table_schema,table_name FROM information_schema.tables WHERE table_schema = 'joe';
-- 创建唯一索引，确保 W_WAREHOUSE_SK 的唯一性
CREATE UNIQUE INDEX ds_warehouse_index1 ON joe.warehouse_t1(W_WAREHOUSE_SK);
-- SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'joe' AND tablename = 'warehouse_t1';
-- 重命名索引 ds_warehouse_index1 为 ds_warehouse_index2
ALTER INDEX joe.ds_warehouse_index1 RENAME TO ds_warehouse_index2;
-- SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'joe' AND tablename = 'warehouse_t1';
-- 删除索引 ds_warehouse_index2
DROP INDEX joe.ds_warehouse_index2;
-- SELECT indexname, indexdef FROM pg_indexes WHERE schemaname = 'joe' AND tablename = 'warehouse_t1';
-- 创建视图 joe.customer_details_view_v1，查询所有 W_WAREHOUSE_SQ_FT 大于100的仓库
CREATE VIEW joe.warehouse_view_v1 AS
    SELECT * FROM joe.warehouse_t1
    WHERE W_WAREHOUSE_SQ_FT > 100;
-- SELECT * FROM information_schema.views WHERE table_schema = 'joe';
-- 将视图的名称从 warehouse_view_v1 修改为 warehouse_view_v2
ALTER VIEW joe.warehouse_view_v1 RENAME TO warehouse_view_v2;
-- SELECT * FROM information_schema.views WHERE table_schema = 'joe';
-- 将视图的架构修改为 jim
ALTER VIEW joe.warehouse_view_v2 SET schema jim;
-- SELECT * FROM information_schema.views WHERE table_schema = 'jim';
-- 删除视图 jim.warehouse_view_v2
DROP VIEW jim.warehouse_view_v2;
-- SELECT * FROM information_schema.views WHERE table_schema = 'jim';
-- 将 joe.warehouse_t1 移动到 jim 架构
ALTER TABLE joe.warehouse_t1 SET SCHEMA jim;
-- 级联删除用户架构 joe
DROP SCHEMA joe CASCADE;
-- SELECT nspname AS schema_name,pg_catalog.pg_get_userbyid(nspowner) AS owner FROM pg_catalog.pg_namespace WHERE nspname NOT LIKE 'pg_%' AND nspname != 'information_schema';

-- DML
-- 向表 jim.warehouse_t1 中插入数据
INSERT INTO jim.warehouse_t1 VALUES
(1, 'W001', 'Main Warehouse', 10000, '123', 'Main St', 'Street', NULL, 'Los Angeles', 'Los Angeles', 'CA', '90001', 'USA', -8.00),
(2, 'W002', 'East Warehouse', 15000, '456', 'East Ave', 'Street', 'A', 'San Francisco', 'San Francisco', 'CA', '94101', 'USA', -8.00),
(3, 'W003', 'South Warehouse', 12000, '789', 'South St', 'Street', NULL, 'San Diego', 'San Diego', 'CA', '92101', 'USA', -8.00),
(4, 'W004', 'West Warehouse', 9000, '321', 'West St', 'Street', NULL, 'Los Angeles', 'Los Angeles', 'CA', '90001', 'USA', -8.00),
(5, 'W005', 'North Warehouse', 11000, '654', 'North St', 'Street', NULL, 'San Jose', 'San Jose', 'CA', '95101', 'USA', -8.00),
(6, 'W006', 'Central Warehouse', 14000, '987', 'Central Ave', 'Street', NULL, 'Sacramento', 'Sacramento', 'CA', '95814', 'USA', -8.00),
(7, 'W007', 'Coastal Warehouse', 13000, '258', 'Coastal Rd', 'Street', NULL, 'Santa Barbara', 'Santa Barbara', 'CA', '93101', 'USA', -8.00);
-- 向表 jim.warehouse_t17 中插入数据
INSERT INTO jim.warehouse_t17 VALUES
(1, 'W001', 'Main Warehouse', 10000, '123', 'Main St', 'Street', NULL, 'Los Angeles', 'Los Angeles', 'CA', '90001', 'USA', -8.00),
(2, 'W002', 'East Warehouse', 15000, '456', 'East Ave', 'Street', 'A', 'San Francisco', 'San Francisco', 'CA', '94101', 'USA', -8.00),
(3, 'W003', 'South Warehouse', 12000, '789', 'South St', 'Street', NULL, 'San Diego', 'San Diego', 'CA', '92101', 'USA', -8.00),
(4, 'W004', 'West Warehouse', 9000, '321', 'West St', 'Street', NULL, 'Los Angeles', 'Los Angeles', 'CA', '90001', 'USA', -8.00),
(5, 'W005', 'North Warehouse', 11000, '654', 'North St', 'Street', NULL, 'San Jose', 'San Jose', 'CA', '95101', 'USA', -8.00),
(6, 'W006', 'Central Warehouse', 14000, '987', 'Central Ave', 'Street', NULL, 'Sacramento', 'Sacramento', 'CA', '95814', 'USA', -8.00),
(7, 'W007', 'Coastal Warehouse', 13000, '258', 'Coastal Rd', 'Street', NULL, 'Santa Barbara', 'Santa Barbara', 'CA', '93101', 'USA', -8.00);
-- 查询表 jim.warehouse_t1 中所有列的所有数据
SELECT * FROM jim.warehouse_t1;
-- 查询表 jim.warehouse_t17 中列 W_WAREHOUSE_ID, W_WAREHOUSE_NAME, W_CITY 的所有数据
SELECT W_WAREHOUSE_ID, W_WAREHOUSE_NAME, W_CITY FROM jim.warehouse_t17;
-- 带 JOIN 查询
SELECT w.W_WAREHOUSE_NAME, w.W_WAREHOUSE_SQ_FT, w.W_CITY, w.W_STATE FROM jim.warehouse_t1 w JOIN jim.warehouse_t17 w17 ON w.W_WAREHOUSE_ID = w17.W_WAREHOUSE_ID;
-- 带 GROUP BY 查询
SELECT W_STATE, COUNT(*) AS warehouse_count FROM jim.warehouse_t1 GROUP BY W_STATE;
-- 更新表 jim.warehouse_t1 中 W_WAREHOUSE_ID 为 W001 的数据行中仓库名
UPDATE jim.warehouse_t1 SET W_WAREHOUSE_NAME = 'Updated Warehouse' WHERE W_WAREHOUSE_ID = 'W001';
-- SELECT * FROM jim.warehouse_t1;
-- 更新仓库 ID 为 W001 的仓库名称
UPDATE jim.warehouse_t1 SET W_WAREHOUSE_NAME = 'Updated Warehouse' WHERE W_WAREHOUSE_ID = 'W001';
-- SELECT * FROM jim.warehouse_t1;
-- 删除表 jim.warehouse_t1 中 W_WAREHOUSE_ID 为 W002 的数据行
DELETE FROM jim.warehouse_t1 WHERE W_WAREHOUSE_ID = 'W002';
-- SELECT * FROM jim.warehouse_t1;
-- 级联删除用户架构 jim
DROP SCHEMA IF EXISTS jim CASCADE;
-- 级联删除用户 jim
DROP USER IF EXISTS jim CASCADE;

-- DCL
-- 创建用户 joe，并设置密码
CREATE USER joe PASSWORD 'Abcd@123';
-- 授予用户 joe 所有权限
GRANT ALL PRIVILEGES TO joe;
-- 创建角色 manager，并设置密码
CREATE ROLE manager PASSWORD 'Abcd@123';
-- 将用户 joe 授予给角色 manager，并允许管理
GRANT joe TO manager WITH ADMIN OPTION;
-- 撤销用户 joe 的所有权限
REVOKE ALL PRIVILEGES FROM joe;
-- 删除用户 joe
DROP USER IF EXISTS joe;
-- 删除角色 manager
DROP ROLE IF EXISTS manager;

-- PROC
-- 创建存储过程 insert_warehouse
CREATE PROCEDURE jim.insert_warehouse (
    param1 INT, param2 CHAR(16), param3 VARCHAR(20)  DEFAULT 'Default Name',
    param4 INT = 0, param5 CHAR(10) DEFAULT '000', 
    param6 VARCHAR(60) DEFAULT 'Default St', param7 CHAR(15) DEFAULT 'Street', 
    param8 CHAR(10)DEFAULT NULL, param9 VARCHAR(60) DEFAULT 'Default City',    
    param10 VARCHAR(30) DEFAULT 'Default County', param11 CHAR(2) DEFAULT 'CA', 
    param12 CHAR(10) DEFAULT '00000', param13 VARCHAR(20) DEFAULT 'USA', 
    param14 DECIMAL(5,2) DEFAULT -8.00)
IS
BEGIN
	IF param1 IS NULL OR param2 IS NULL THEN
        RAISE EXCEPTION 'W_WAREHOUSE_SK and W_WAREHOUSE_ID cannot be NULL';
    END IF;
    INSERT INTO jim.warehouse_t1 VALUES (
        param1, param2, param3, param4, param5,param6, param7,
        param8, param9, param10, param11, param12, param13, param14);
END;
/
-- SELECT proname FROM pg_proc WHERE pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'jim');
-- 正确调用示例
CALL jim.insert_warehouse(1, 'W001', 'Main Warehouse', 10000);
-- SELECT * FROM jim.warehouse_t1;
-- 错误调用示例
CALL jim.insert_warehouse(NULL, NULL, 'Invalid Warehouse', 20000);
-- 删除存储过程
DROP PROCEDURE jim.insert_warehouse;
~~~

对于事务的设计，HikariCP 连接池会在每个语句执行后自动提交事务。使用 HikariCP 连接 openGauss 数据库时，默认情况下每个 SQL 语句会在一个独立的事务中执行。若想令多个 SQL 成为一个原子操作，需要关闭自动提交（AutoCommit），并在同一原子操作的sql执行完成后统一 commit ，若中途出现异常则需要 rollback 。

+ [CREATE\DROP\ALTER] [DATABASE\TABLESPACE] 不能在一个事务块中运行。这些操作需要在单独的事务中执行，因为其会影响数据库的结构或元数据，不能被回滚。
+ gsql 中，创建用户时会自动创建一个同名的 schema。即 gsql 将每个用户与一个默认的 schema 关联，以便于组织和管理对象。
+ gsql 中，所有用户都是角色，但只有 rolcanlogin=True 的角色可以被称为用户。

pg_roles表主要列属性：

+ rolname——角色名
+ rolsuper——布尔值，指示该角色是否为超级用户（可以执行任何操作）
+ rolinherit——布尔值，指示该角色是否可以继承其父角色的权限
+ rolcreaterole——布尔值，指示该角色是否有权限创建新角色
+ rolcreatedb——布尔值，指示该角色是否有权限创建新数据库
+ rolcanlogin——布尔值，指示该角色是否可以登录
+ rolreplication——布尔值，指示该角色是否有权限进行数据库复制



### HikariCP API

<u>HikariConfig</u>是 HikariCP 连接池的配置类，负责管理连接池的各种参数和属性。

+ **连接参数**
  + catalog：数据库目录
  + connectionTimeout：获取连接的超时时间，默认30s
  + validationTimeout：验证连接的超时时间，默认5s
  + idleTimeout：连接空闲超时时间，默认10min
  + maxLifetime：连接的最大生命周期，默认30min
  + maxPoolSize：连接池的最大大小，默认10
  + minIdle：最小空闲连接数
+ **数据源配置**

  + username：数据库用户名
  + password：数据库密码
  + jdbcUrl：数据库连接 URL
  + poolName：连接池名称
  + dataSource：数据源示例

  + dataSourceClassName：数据源类名
  + dataSourceProperties：其他数据源属性
  + driveClassName：JDBC 驱动类名
+ **事务和连接管理**
  + isAutoCommit：是否自动提交事务
  + transactionIsolationName：事物隔离级别名称
  + connectionInitSql：初始化连接时执行的 SQL。每次连接从池中获取时执行，主要用于初始化连接。
  + connectionTestQuery：连接测试查询。测试连接是否有效，主要用于确保连接的可用性。
  
+ **线程和调度**
  + threadFactory：线程工厂。用于创建线程
  + scheduledExecutor：调度执行器服务。用于定期执行任务，如连接池健康检查
  + metricsTrackerFactory：指标跟踪工程。用于收集连接池性能指标。
  + metricRegistry：指标注册表。用于注册和管理性能指标。
  + healthCheckRegistry：健康检查注册表。用于注册和管理健康检查。
  + healthCheckProperties：健康检查属性。用于配置健康检查的相关参数。
  + keepaliveTime：连接保持活动时间。连接池在空闲时保持连接活动的时间。
  + sealed：是否封闭。用于指示连接池是否已被封闭，不再允许更改配置
+ **其他配置**
  + leakDetectionThreshold：连接泄露检测阈值 ms。若连接在获取后未被正常关闭，超过该阈值会记录泄露警告，默认值为 0（禁用）。
  + initializationFailTimeout：初始化失败超时时间。连接池初始化时，若无法连接到数据库，将会在该时间内抛出异常，默认为 1s。
  + dataSourceJndiName：数据源 JNDI 名称。使用 JNDI 查找数据源需配置此项。
  + exceptionOverrideClassName：异常覆盖类名。自定义异常处理类。
  + schema：数据库 schema。用于指定连接的默认 schema。
  + isReadOnly：是否只读。配置连接是否只读。 
  + isIsolateInternalQueries：是否隔离内部查询。用于隔离内部数据库操作，以避免影响其他连接。
  + isRegisterMbeans：是否注册 MBeans。用于将 HikariCP 的监控信息注册到 JMX 中。
  + isAllowPoolSuspension：是否允许连接池在特定情况下暂停。

**hikari.properties设置**

~~~java
# JDBC URL
dataSourceClassName=org.postgresql.ds.PGSimpleDataSource
dataSource.user=tpcds
dataSource.password=Abcd@1234
dataSource.url=jdbc:postgresql://192.168.131.66:5432/tpcds_db

# HikariCP settings
poolName=hikariPool
maximumPoolSize=20
minimumIdle=10
idleTimeout=60000
maxLifetime=1800000
validationTimeout=5000
connectionTimeout=30000
autoCommit=true

# JMX
registerMbeans=true
allowPoolSuspension=false

connectionTestQuery=SELECT 1
~~~



<u>HikariPoolMXBean</u> 主要提供与连接池相关的管理和监控功能。

+ **监控**

  + getIdleConnections() 监控当前池中空闲连接的数量	

  + getActiveConnections() 监控当前正在使用的连接数量

  + getTotalConnections() 监控池中总连接数（包括空闲和活动连接）

  + getThreadsAwaitingConnection() 获取当前等待获取连接的线程数量

+ **管理**

  + softEvictConnections() 软驱逐连接。标记所有连接为可关闭状态
  + suspendPool() 暂停连接池。连接池不在分配新的连接，但已分配连接将继续使用直至释放
  + resumePool() 恢复连接池。恢复已暂停连接池



HikariConfigMXBean 是 HikariCP 提供的一个管理接口，用于在运行时动态配置和管理连接池的参数。其包含一系列的 get 和 set 方法。

+ **get**
  + 连接超时（Connection Timeout）
  + 验证超时（Validation Timeout）
  + 空闲超时（Idle Timeout）
  + 泄露检查阈值（Leak Detection Threshold）
  + 最大生命周期（Max Lifetime）
  + 最小空闲连接数（Minimum Idle）
  + 最大连接数（Maximum Pool Size）
  + <u>用户名（Username）</u>
  + <u>密码（Password）</u>
  + <u>连接池名称（Pool Name）</u>
  + 目录（Catalog）
+ **set**
  + 连接超时（Connection Timeout）
  + 验证超时（Validation Timeout）
  + 空闲超时（Idle Timeout）
  + 泄露检查阈值（Leak Detection Threshold）
  + 最大生命周期（Max Lifetime）
  + 最小空闲连接数（Minimum Idle）
  + 最大连接数（Maximum Pool Size）
  + 目录（Catalog）



<u>HikariPool</u> 类是 HikariCP 连接池的核心实现，负责管理数据库连接池的创建、分配、回收。

+ 连接池状态 (poolState)
  + POOL_NORMAL=0 ：正常运行状态
  + POOL_SUSPENDED=1 ：暂停状态
  + POOL_SHUTDOWN=2 ：关闭状态，连接池不再提供服务
+ 连接创建器 (PoolEntryCreator)
  + PoolEntryCreator 是一个内部类，负责实际的连接创建。HikariPool 通过该类异步创建新的连接并将其添加到连接池中。
  + poolEntryCreator 和 poolFillPoolEntryCreator 都被声明为 PoolEntryCreator 类型。poolFillPoolEntryCreator 在构造函数中初始化为带 "After adding" 的实例，用于在日志记录中区分不同的连接创建任务。
+ 线程池执行器 (ThreadPoolExecutor)
  + addConnectionExecutor 用于管理创建新连接的线程池。这个线程池负责异步创建新的数据库连接，以避免阻塞主线程或影响应用性能。
  + closeConnectionExecutor 用于管理关闭连接的线程池。连接关闭是一个耗时的操作，将其交给独立线程池异步操作以不影响其他操作。
+ 连接包 (connectionBag)。ConcurrentBag 是一个线程安全的连接集合，存储了连接池中的所有连接 (PoolEntry对象)。同时，ConcurrentBag 提供了高效的并发操作，允许多个线程安全地获取和释放连接。
+ 泄露检测 (leakTaskFactory) 用来创建泄露检测任务。HikariCP 会检测连接泄露，若一个连接被长时间占用而未释放，HikariCP 会触发泄露检测机制，记录日志或采取措施。
+ 暂停与恢复锁 (suspendResumeLock) 用于管理连接池暂停和恢复状态的锁，可以保证当连接池处于暂停状态时不会分配新的连接，直到池被恢复。
+ 定期清理任务
  + 定期清理任务调度器 (houseKeepingExecutorService) 负责定期执行连接池清理任务，如逐出过期连接、关闭空闲连接等。
  + 定期清理任务 (houseKeeperTask) 是调度的定期任务，其会定期检查连接池状态，执行清理操作。这些操作包括逐出失效连接、关闭不需要的空闲连接等
+ aliveBypassWindowMs，该值为检查连接是否活着的空窗期，默认值 500ms。若一个连接从上次使用到现在不到 500ms 就默认其活着，超过 500ms 才检查。
+ housekeepingPeriodMs，默认值 30s，表示每 30s 执行一次连接池维护任务。



### 测试方法

+ 兼容性测试
  + 验证 HikariCP 使用 MySQL JDBC 驱动/PG JDBC 驱动连接 openGauss 数据库时能否创建数据源并正确获得连接，是否支持 openGauss 特有的功能和数据类型如dolphin协议。同时测试对 openGauss 存储过程的支持。
  + 测试驱动特有的功能和特性，验证这些功能在 openGauss 数据库能否正常工作。
+ 基本操作测试
  + 通过 HikariCP 连接 openGauss 数据库，逐语句运行并输出结果。对比数据库中产生的结果，分析语句执行的正确性及一致性。如有异常，记录并分析原因。
  + 设置连接池和 connection 的隔离级别，测试两者之间关系，验证事务隔离级别是否符合设置。
    + 默认情况下，获取到 connection 后，总是处于“自动提交”模式，也就是每一条 SQL 都是作为事务自动执行的。
    + 可以通过 setTransactionIsolation() 设置连接的隔离级别
  + 事务隔离级别
    + TRANSACTION_READ_UNCOMMITTED
    + TRANSACTION_READ_COMMITTED
    + TRANSACTION_REPEATABLE_READ
    + TRANSACTION_SERIALIZABLE
+ 异常处理测试
  + 测试 HikariCP 在连接失效或数据库重启时的处理能力。通过手动重启数据库实例模拟连接失效，验证连接池正确处理坏连接并自动恢复的能力。记录连接池在数据库重启或连接失效后，恢复正常的时间，并验证连接池能否正确地回收失效连接并替换成新的连接。
  + 测试 HikariCP 连接超时、查询超时等配置是否生效，并验证超时错误能否被正确捕获和处理。设置 HikariCP 的连接超时（connectionTimeout）和查询超时（maxLifetime、idleTimeout）设置，并通过PreparedStatement.setQueryTimeout() 设置查询超时时间。执行慢 SQL 或人为延迟模拟超时情况（Thread.sleep()），验证超时设置是否生效。验证捕获超时异常的逻辑，记录并分析超时错误的日志信息。
+ 配置验证
  + 验证 HikariCP 的配置参数能否正确影响连接池的行为并在实际使用时生效，记录和观察连接池日志所记录的连接池的状态、性能指标和错误信息。
  + 验证不同配置参数对 openGauss 数据库的影响，监控配置变更对测试性能的影响。测试各种参数配置形式，全量测试 HikariCP 的 API 接口。
+ 资源管理
  + 验证 HikariCP 能否正确管理数据库连接，所有连接在使用后能够被正确关闭，且连接池中不会出现泄露的连接。
  + 使用 'try-with-resources' ，确保每个数据库操作完成后都显式地关闭连接，使用HikariCP提供的监控接口（HikariPoolMXBean）定期检查连接池状态。引入异常（错误的SQL），验证异常发生时连接能被正确关闭。
  + 运行负载测试工具对 HikariCP 进行长时间的负载测试，模拟真实生产环境。使用 JDK 自带的 JConsole 工具监控运行情况，检查是否存在未关闭连接。分析内存快照，检查是否存在长时间持有的对象或未释放的内存。监控 HikariCP 在长时间运行中的内存使用情况，记录内存使用的趋势，观察是否有异常的内存增长，检查是否存在内存泄露的迹象。设置配置参数 leakDetectionThreshold，若发生内存泄漏情况，验证该参数能否正确发挥作用。



## 技术架构

### 数据库连接配置

'HikariUtil' 类提供了一个用于管理和操作 HikariCP 数据源的实用工具类，封装一些常见的 HikariCP 连接池管理相关操作。通过 'HikariConfig' 配置数据库连接参数，提供数据库连接、获取连接池的管理 Bean 以及关闭数据源等操作。

### 模拟负载生成器

用于模拟应用程序使用 HikariCP 连接 openGauss 数据库。使用多线程模拟并发数据库操作，通过 'ExecutorService' 创建固定数量的线程池，每个线程执行一定数量的数据库操作。在每次请求结束时，记录响应时间；每秒统计一次处理的请求数，用于计算吞吐量。

### 连接池指标收集器

收集负载执行时 HikariPoolMXBean 中指标数据 idleConnections、activeConnections、totalConnections、threadAwaitingConnection，绘制折线图。

### 外部工具

+ JConsole、jhat——监控程序内存使用情况
+ VisualVM——分析内存快照
+ SLF4J——提供统一日志 API
+ Logback——提供实际日志功能
+ JUnit——测试框架
+ XChart——绘制图表
+ TPCH/DS——提供数据库数据以及慢查询语句
+ mysql-connector-java——MySQL 驱动用于连接 openGauss 数据库
+ opengauss-jdbc——PG 驱动用于连接 openGauss 数据库



## 代码和测试结果示例

代码仓库：

[郑雅丹/test_hikari - 码云 - 开源中国 (gitee.com)](https://gitee.com/Adamzheng/test_hikari/tree/adam/)

+ HikariCP 启动数据库连接的日志分析

  程序使用 SLF4J 作为 HikariCP 连接池的日志接口，使用 Logback 提供日志功能。在程序运行开始，HikariCP 会输出此次程序运行时连接池配置详情。

  ~~~
  14:46:43.180 [main] DEBUG com.zaxxer.hikari.HikariConfig - hikariPool - configuration:
  14:46:43.194 [main] DEBUG com.zaxxer.hikari.HikariConfig - allowPoolSuspension.............false
  14:46:43.194 [main] DEBUG com.zaxxer.hikari.HikariConfig - autoCommit......................true
  14:46:43.194 [main] DEBUG com.zaxxer.hikari.HikariConfig - catalog.........................none
  14:46:43.194 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionInitSql...............none
  14:46:43.196 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionTestQuery............."SELECT 1"
  14:46:43.196 [main] DEBUG com.zaxxer.hikari.HikariConfig - connectionTimeout...............30000
  14:46:43.196 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSource......................none
  14:46:43.197 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceClassName............."org.postgresql.ds.PGSimpleDataSource"
  14:46:43.197 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceJNDI..................none
  14:46:43.197 [main] DEBUG com.zaxxer.hikari.HikariConfig - dataSourceProperties............{password=<masked>, user=tpcds, url=jdbc:postgresql://192.168.131.66:5432/tpcds_db}
  14:46:43.197 [main] DEBUG com.zaxxer.hikari.HikariConfig - driverClassName.................none
  14:46:43.197 [main] DEBUG com.zaxxer.hikari.HikariConfig - exceptionOverrideClassName......none
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - healthCheckProperties...........{}
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - healthCheckRegistry.............none
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - idleTimeout.....................60000
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - initializationFailTimeout.......1
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - isolateInternalQueries..........false
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - jdbcUrl.........................none
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - keepaliveTime...................0
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - leakDetectionThreshold..........0
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - maxLifetime.....................1800000
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - maximumPoolSize.................10
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - metricRegistry..................none
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - metricsTrackerFactory...........none
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - minimumIdle.....................5
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - password........................<masked>
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - poolName........................"hikariPool"
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - readOnly........................false
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - registerMbeans..................true
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - scheduledExecutor...............none
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - schema..........................none
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - threadFactory...................internal
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - transactionIsolation............default
  14:46:43.198 [main] DEBUG com.zaxxer.hikari.HikariConfig - username........................none
  14:46:43.199 [main] DEBUG com.zaxxer.hikari.HikariConfig - validationTimeout...............5000
  ~~~

  PostgreSQL JDBC 驱动尝试连接到数据库，连接已成功建立，标识符为 ffab598b-712d-4e3c-81f7-42e9f7a2ee10。日志显示 HikariCP 连接池成功将一个新的连接(PgConnection@1573f9fc) 添加到池中。本地地址和端口为：192.168.131.1：50927，远程地址和端口为：192.168.131.66:5432。

  ~~~
  9月 05, 2024 2:55:24 下午 org.postgresql.core.v3.ConnectionFactoryImpl openConnectionImpl
  信息: [ffab598b-712d-4e3c-81f7-42e9f7a2ee10] Try to connect. IP: 192.168.131.66:5432
  9月 05, 2024 2:55:25 下午 org.postgresql.core.v3.ConnectionFactoryImpl openConnectionImpl
  信息: [192.168.131.1:53282/192.168.131.66:5432] Connection is established. ID: ffab598b-712d-4e3c-81f7-42e9f7a2ee10
  9月 05, 2024 2:55:25 下午 org.postgresql.core.v3.ConnectionFactoryImpl openConnectionImpl
  信息: Connect complete. ID: ffab598b-712d-4e3c-81f7-42e9f7a2ee10
  14:55:25.110 [main] INFO com.zaxxer.hikari.pool.HikariPool - hikariPool - Added connection org.postgresql.jdbc.PgConnection@1573f9fc
  ~~~

  HikariCP 连接池数据源启动至启动完成。

  ~~~
  14:55:24.752 [main] INFO com.zaxxer.hikari.HikariDataSource - hikariPool - Starting...
  14:55:25.166 [main] INFO com.zaxxer.hikari.HikariDataSource - hikariPool - Start completed.
  ~~~

  连接池状态日志。显示连接池状态，包括总连接数 (10)、活动连接数 (10)、空闲连接数 (0) 和等待连接数 (6)。

  [hikariPool housekeeper] 是 HikariCP 连接池的一个内部线程，负责定期维护和检查连接池的状态，包括清理超时连接、检查空闲连接、更新连接池状态等。其每隔一定的时间间隔 (30s) 执行一次状态检查和维护操作。

  ~~~
  15:19:18.672 [hikariPool housekeeper] DEBUG com.zaxxer.hikari.pool.HikariPool - hikariPool - Before cleanup stats (total=10, active=10, idle=0, waiting=6)
  ~~~

  HikariCP 正在进行大量的连接池添加操作，当前有较多的连接请求在等待，同时多个线程在处理连接添加，省略详细日志以简化输出。waiting=1 表示当前有 1 个连接请求正在等待被满足，adders pendings/running=2 表示当前有 2 个线程正在处理连接添加操作，其中包括待处理和正在运行的线程。

  ~~~
  15:22:01.276 [pool-2-thread-16] DEBUG com.zaxxer.hikari.pool.HikariPool - hikariPool - Add connection elided, waiting=1, adders pending/running=2
  ~~~

  日志信息 [hikariPool connection adder] 是连接池添加器

  com.zaxxer.hikari.pool.PoolBase：HikariCP 基础池类，负责连接池的核心操作

  com.zaxxer.hikari.pool.HikariPool：HikariCP 的连接池类，负责创建和管理连接

+ 基本操作测试

  + 代码示例

  ~~~java
  @Test
  public void SQLexecute() throws SQLException, IOException {
      String outputFileName = "sql/user_defined/outfile.txt";
      try (Connection conn = HikariUtil.getConnection()) {
          String query = "SELECT * FROM pg_roles;";
          try (PreparedStatement pstmt = conn.prepareStatement(query)) {
              boolean hasResultSet = pstmt.execute();
              if (hasResultSet) {
                  try (ResultSet rs = pstmt.getResultSet()) {
                      writeResultSetToFile(rs, outputFileName);
                  } catch (SQLException e) {
                      e.printStackTrace();
                      throw e;
                  }
              }
          } catch (SQLException | IOException e) {
              e.printStackTrace();
          }
      }
  }
  ~~~

  + 测试结果
    + 基于 HikariCP 连接池测试了部分 DDL、DML、DCL 语句，并使用 JDBC 连接以及 openGauss 数据库客户端验证语句执行结果的正确性及一致性。在目前的测试用例中未发现问题
    + 测试 HikariCP 连接池的事务隔离机制。连接池、连接的事务隔离级别设置对于数据库有效，连接池的事务隔离机制依赖于 openGauss 数据库的事务隔离机制，连接的事务隔离级别优先级高于连接池事务隔离级别。事务的提交和回滚在 HikariCP 和 openGauss 数据库之间能正常同步
    + [基本操作测试细节 ](https://docs.qq.com/doc/DQndNWVhIVFRMWEVr)

+ 异常处理测试

  + 代码示例

  ~~~java
  /**
   * 测试HikariCP连接池在数据库连接中断时的处理机制
   * 测试HikariCP连接池对超时查询连接的处理机制
  */
  @Test
  public void error_test() {
  	logger.info("error test ...");
  	String sql = "select * from store_sales";
  	try (Connection conn = HikariUtil.getConnection()){
  		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
  			pstmt.setQueryTimeout(2);   // 2s
   			pstmt.execute();
  		}
  	} catch (SQLException e) {
  		String sqlState = e.getSQLState();
  		int errorCode = e.getErrorCode();
  		logger.error("SQL Exception occurred. SQLState: {}, ErrorCode: {}, SQL: {}, Thread: {}", sqlState, errorCode, sql, Thread.currentThread().getName(), e);
          e.printStackTrace();
  	}
      
      try (Connection conn = HikariUtil.getConnection()){
  		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
              logger.info("start to execute the sql2");
              pstmt.execute();
          }
      } catch (SQLException e) {
          e.printStackTrace();
      }
  }
  ~~~

  + 测试结果
    + 收集分析报错信息，整理 HikariCP 连接池异常处理逻辑
    + 分析异常原因与报错信息是否对应

+ 兼容性测试

  + 分别使用 MySQL 驱动和 PG 驱动连接 openGauss 数据库，测试 HikariCP 连接池与驱动的兼容性。openGauss 通过抽象协议层接口，在 dolphin 插件中实现了 MySQL 协议兼容，在服务器设置相关参数后，可通过MySQL的JDBC driver直接连接 openGauss 。故当使用 MySQL 驱动连接 openGauss 数据库时需先配置[dolphin插件](https://docs-opengauss.osinfra.cn/zh/docs/latest/docs/ExtensionReference/dolphin-MySQL协议兼容.html)，详细配置过程如下。

  ~~~sql
  --创建B类数据库及用户
  CREATE DATABASE proto_test_db DBCOMPATIBILITY 'B';
  \c proto_test_db
  CREATE USER proto_test WITH PASSWORD 'Proto_test123';
  SELECT set_native_password('proto_test', 'Proto_test123');
  
  --查看插件是否已被创建
  \dx
  
  --配置GUC参数 enable_dolphin_proto。该配置为POSTMASTER类型，修改后重启生效
  gs_guc reload -N all -I all -c "enable_dolphin_proto=on"
  gs_om -t restart
  
  --查看MySQL协议监听端口号
  show dolphin_server_port;
  
  --查看dolphin默认数据库是否为proto_test_db
  show dolphin.default_database_name;
  ~~~

  + 测试结果
    + HikariCP 连接池使用 MySQL 驱动、PG 驱动连接 openGauss 数据库的兼容性
    + 原因分析

+ 配置验证

  + 调整 hikari.properties 配置，观察该修改是否生效，是否产生预期效果
  + 测试结果
    + 收集数据
    + 原因分析

+ 资源管理

  + 连接池在物理机上运行，故使用 jConsole 连接监控本地计算机上运行的 JVM 进程。观察进程是否死锁，程序运行时资源使用情况，运行结束后资源是否合理释放

  + 测试结果

    + 收集数据
    + 分析原因

    


## 总结与展望

+ 测试项设置旨在检测 HikariCP 使用 PG 驱动与 MySQL 驱动连接 openGauss 数据库时兼容性，测试语句为 openGauss 常用的 DDL、DML、DCL、存储过程等语法，测试内容涉及连接是否安全、配置是否生效等。
+ 后续工作可以从以下方面展开：
  + 提升 openGauss 与 HikariCP 兼容性，确保配置项在各个场景下均能有效执行。
  + 对比 HikariCP 与其他数据库连接池（如 C3P0、Druid）在连接 openGauss 时的性能表现，评估 HikariCP 连接 openGauss 数据库的性能。
  + 探索 HikariCP 连接池对于不同生产环境下的较优配置，确保其能够更好地适应实际需求。
